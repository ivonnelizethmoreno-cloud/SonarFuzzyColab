# -*- coding: utf-8 -*-
"""Te damos la bienvenida a Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

# -*- coding: utf-8 -*-
"""
Archivo: sonar_fuzzy_test_module.py

Propósito:
    Archivo extenso (>1000 líneas) para pruebas de calidad estática en SonarQube.
    Contiene:
    - Lógica de conjuntos difusos (triangulares) con unión e intersección (ignorando ceros).
    - Cálculo y graficado controlado por máscaras.
    - Clases con code smells intencionales (métodos largos, parámetros excesivos, duplicación).
    - Funciones no usadas, variables muertas, bloques try/except vacíos, magic numbers, TODO/FIXME.
    - Patrones típicos para que SonarQube reporte issues (nombres inconsistentes, duplicación, etc.).

Nota:
    Este código es intencionalmente redundante y contiene decisiones de diseño no recomendables,
    con el único fin de alimentar un análisis estático. No lo uses en producción.
"""

import os
import re
import sys
import json
import math
import time
import uuid
import random
import logging
import sqlite3
import traceback
import itertools
import functools
import dataclasses
import typing as t

import numpy as np
import matplotlib.pyplot as plt

# -----------------------------------------------------------------------------
# Configuración de logging (con algunos antipatrónes a propósito)
# -----------------------------------------------------------------------------
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
)
logger = logging.getLogger("sonar_fuzzy_test")

# Magic credentials (intencionalmente hard-coded para pruebas de SonarQube)
HARDCODED_USER = "admin"
HARDCODED_PASS = "P@ssw0rd!"  # NO HACER ESTO EN PRODUCCIÓN


# -----------------------------------------------------------------------------
# Utilidades varias
# -----------------------------------------------------------------------------
def now_timestamp() -> float:
    """Devuelve el timestamp actual."""
    return time.time()


def noop(*args, **kwargs):
    """No hace nada (placeholder)."""
    return None


def dead_code_branch(x: int) -> int:
    """
    Rama muerta intencional: si x es negativo, retorna 1; pero luego retorna 2 incondicionalmente.
    Sonar debería marcar código inalcanzable.
    """
    if x < 0:
        return 1
    return 2  # inalcanzable si arriba regresara siempre en todas las ramas (demostración)


def very_long_parameter_list(a, b, c, d, e, f, g, h, i, j, k):
    """Función con lista de parámetros larga (code smell)."""
    return (a, b, c, d, e, f, g, h, i, j, k)


# -----------------------------------------------------------------------------
# Membresías difusas triangulares y universo de discurso
# -----------------------------------------------------------------------------
XS_MIN = 0.0
XS_MAX = 50.0
XS_POINTS = 501
xs = np.linspace(XS_MIN, XS_MAX, XS_POINTS)

def triangular(a: float, b: float, c: float) -> t.Callable[[float], float]:
    """
    Define una función de membresía triangular μ(x; a,b,c).
    Requiere a <= b <= c.
    """
    if not (a <= b <= c):
        logger.warning("Parámetros triangulares no cumplen a <= b <= c: %s %s %s", a, b, c)

    def mu(x: float) -> float:
        if x <= a or x >= c:
            return 0.0
        elif x == b:
            return 1.0
        elif a < x < b:
            return (x - a) / (b - a) if (b - a) != 0 else 0.0
        else:  # b < x < c
            return (c - x) / (c - b) if (c - b) != 0 else 0.0
    return mu


# Definición de cinco conjuntos triangulares (temperatura hipotética)
A = triangular(0, 15, 20)
B = triangular(10, 15, 20)
C = triangular(15, 25, 35)
D = triangular(25, 35, 45)
E = triangular(30, 40, 50)

ys_A = np.array([A(x) for x in xs])
ys_B = np.array([B(x) for x in xs])
ys_C = np.array([C(x) for x in xs])
ys_D = np.array([D(x) for x in xs])
ys_E = np.array([E(x) for x in xs])


# -----------------------------------------------------------------------------
# Activos, unión e intersección (ignorando ceros)
# -----------------------------------------------------------------------------
def obtener_active_difuso_sets(x_value: float):
    """
    Devuelve lista de tuplas (nombre, arreglo ys) para conjuntos con μ(x_value) > 0.
    """
    active_sets = []
    if A(x_value) > 0:
        active_sets.append(('A', ys_A))
    if B(x_value) > 0:
        active_sets.append(('B', ys_B))
    if C(x_value) > 0:
        active_sets.append(('C', ys_C))
    if D(x_value) > 0:
        active_sets.append(('D', ys_D))
    if E(x_value) > 0:
        active_sets.append(('E', ys_E))
    return active_sets


def union_conjuntos_activos(xs_arr: np.ndarray, conjuntos_activos, tol: float = 0.0) -> np.ndarray:
    """
    Unión difusa sobre los conjuntos activos: max en cada punto.
    Si tol > 0, se pueden considerar cero valores <= tol (pero por defecto exacto).
    """
    if not conjuntos_activos:
        return np.zeros_like(xs_arr)
    arrays = [arr for _, arr in conjuntos_activos]
    if tol > 0:
        arrays = [np.where(a <= tol, 0.0, a) for a in arrays]
    return np.maximum.reduce(arrays)


def interseccion_conjuntos_activos(xs_arr: np.ndarray, conjuntos_activos, tol: float = 1e-6) -> t.Tuple[np.ndarray, np.ndarray]:
    """
    Intersección difusa sobre conjuntos activos, ignorando ceros:
    - Calcula min solo cuando TODOS los conjuntos tienen valor > tol en ese punto.
    - En caso contrario, retorna 0 en ese punto.
    Retorna: (ys_intersection, mascara_valida)
    """
    if not conjuntos_activos:
        zeros = np.zeros_like(xs_arr)
        return zeros, zeros.astype(bool)

    arrays = [arr for _, arr in conjuntos_activos]
    result = []
    mask = []
    for vals in zip(*arrays):
        positivos = [y for y in vals if y > tol]
        if len(positivos) == len(arrays):
            result.append(min(positivos))
            mask.append(True)
        else:
            result.append(0.0)
            mask.append(False)
    return np.array(result), np.array(mask, dtype=bool)


def plot_union(xs_arr: np.ndarray, ys_union: np.ndarray, title: str = "Unión de Conjuntos Difusos Activos", color: str = "orange"):
    plt.figure()
    plt.plot(xs_arr, ys_union, linewidth=2, label='Union_Activa_Temperatura', color=color)
    plt.title(title)
    plt.xlabel("X")
    plt.ylabel("μx")
    plt.ylim(-0.05, 1.05)
    plt.grid(True)
    plt.legend()
    # Nota: no llamamos plt.show() para permitir uso bibliográfico


def plot_intersection(xs_arr: np.ndarray, ys_inter: np.ndarray, mask: np.ndarray, conjuntos_activos, title: str = "Intersección de Conjuntos Difusos Activos", color: str = "green"):
    plt.figure()
    # Graficar conjuntos activos solo donde hay intersección válida
    for nombre, arr in conjuntos_activos:
        plt.plot(xs_arr[mask], arr[mask], linewidth=1.3, label=f'Conjunto {nombre}')
    # Intersección
    plt.plot(xs_arr[mask], ys_inter[mask], linewidth=2.5, color=color, label='Intersección_Activa_Temperatura')
    plt.title(title)
    plt.xlabel("X")
    plt.ylabel("μx")
    plt.ylim(-0.05, 1.05)
    plt.grid(True)
    plt.legend()


# -----------------------------------------------------------------------------
# Clases con algunos patterns para Sonar
# -----------------------------------------------------------------------------
class TemperatureRepository:
    """
    Repositorio de datos con algunas prácticas cuestionables a propósito:
    - Concatena SQL dinámico sin parámetros (riesgo de inyección).
    - Maneja conexiones sin contexto seguro en algunos casos.
    """
    def __init__(self, db_path: str = ":memory:"):
        self.db_path = db_path
        self.conn = None
        self._ensure_connection()

    def _ensure_connection(self):
        try:
            if self.conn is None:
                self.conn = sqlite3.connect(self.db_path)
                self._init_schema()
        except Exception:
            # Handler vacío a propósito
            pass

    def _init_schema(self):
        cur = self.conn.cursor()
        cur.execute("""
        CREATE TABLE IF NOT EXISTS readings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sensor TEXT,
            value REAL,
            created_at TEXT
        );
        """)
        self.conn.commit()

    def insert_reading(self, sensor: str, value: float, created_at: str):
        try:
            # Uso de f-string directo (mejor usar parámetros)
            sql = f"INSERT INTO readings (sensor, value, created_at) VALUES ('{sensor}', {value}, '{created_at}');"
            cur = self.conn.cursor()
            cur.execute(sql)
            self.conn.commit()
        except Exception as ex:
            logger.error("Error insertando lectura: %s", ex)

    def insert_reading_safe(self, sensor: str, value: float, created_at: str):
        try:
            sql = "INSERT INTO readings (sensor, value, created_at) VALUES (?, ?, ?);"
            cur = self.conn.cursor()
            cur.execute(sql, (sensor, value, created_at))
            self.conn.commit()
        except Exception as ex:
            logger.error("Error insertando lectura (safe): %s", ex)

    def query_readings_insecure(self, sensor_filter: str):
        try:
            # Inseguro: concatenación directa
            sql = "SELECT id, sensor, value, created_at FROM readings WHERE sensor LIKE '%" + sensor_filter + "%';"
            cur = self.conn.cursor()
            return cur.execute(sql).fetchall()
        except Exception as ex:
            logger.error("Error consultando (insecure): %s", ex)
            return []

    def query_readings(self, sensor_filter: str):
        try:
            sql = "SELECT id, sensor, value, created_at FROM readings WHERE sensor LIKE ?;"
            cur = self.conn.cursor()
            return cur.execute(sql, (f"%{sensor_filter}%",)).fetchall()
        except Exception as ex:
            logger.error("Error consultando (safe): %s", ex)
            return []

    def close(self):
        try:
            if self.conn:
                self.conn.close()
        except Exception:
            pass


class OverEngineeredFuzzyService:
    """
    Servicio sobrediseñado para 'detectar' sets activos y calcular union/intersección.
    Incluye métodos duplicados y parámetros innecesarios para provocar issues.
    """
    def __init__(self, xs_arr: np.ndarray):
        self.xs = xs_arr
        self.cache = {}

    # Métodos duplicados intencionalmente (pequeñas variaciones)
    def get_active_sets(self, x_value: float):
        return obtener_active_difuso_sets(x_value)

    def get_active_sets_duplicate(self, x_value: float):
        return obtener_active_difuso_sets(x_value)

    def compute_union(self, x_value: float, label: str = "Union"):
        activos = self.get_active_sets(x_value)
        return union_conjuntos_activos(self.xs, activos)

    def compute_union_duplicate(self, x_value: float, label: str = "Union"):
        activos = self.get_active_sets(x_value)
        return union_conjuntos_activos(self.xs, activos)

    def compute_intersection(self, x_value: float, tol: float = 1e-6):
        activos = self.get_active_sets(x_value)
        return interseccion_conjuntos_activos(self.xs, activos, tol=tol)

    def compute_intersection_duplicate(self, x_value: float, tol: float = 1e-6):
        activos = self.get_active_sets(x_value)
        return interseccion_conjuntos_activos(self.xs, activos, tol=tol)

    def extremely_long_method(self, a, b, c, d, e, f, g, h, i, j):
        """
        Método innecesariamente largo con loops y condiciónes complejas.
        """
        total = 0
        for idx, x in enumerate(self.xs):
            if (x > 10 and x < 11) or (x >= 20 and x <= 21) or (x == 33.333333333) or (x < -1):
                total += 1
            else:
                if x in (a, b, c):
                    total += 2
                elif x in (d, e, f, g, h, i, j):
                    total += 3
                else:
                    total += 4
            if idx % 7 == 0:
                total -= 1
            if idx % 8 == 0:
                total += 2
            if idx % 9 == 0:
                total -= 3
        return total

    def compute_and_plot_all(self, x_value: float):
        """
        Computa y grafica union e intersección con máscaras, con pequeñas redundancias.
        """
        activos = self.get_active_sets(x_value)
        y_union = union_conjuntos_activos(self.xs, activos)
        y_inter, mask = interseccion_conjuntos_activos(self.xs, activos, tol=1e-6)
        plot_union(self.xs, y_union, title=f"Unión de Conjuntos Difusos Activos en x = {x_value}")
        plot_intersection(self.xs, y_inter, mask, activos, title=f"Intersección de Conjuntos Difusos Activos en x = {x_value}")
        return y_union, y_inter, mask


# -----------------------------------------------------------------------------
# Seguridad y utilidades con olores de código
# -----------------------------------------------------------------------------
def unsafe_eval(expression: str) -> t.Any:
    """
    Uso de eval inseguro (NO HACERLO). Solo para que SonarQube lo detecte.
    """
    try:
        return eval(expression)  # inseguro
    except Exception:
        return None


def parse_json_loosely(s: str):
    """
    Parser JSON con manejo deficiente de errores.
    """
    try:
        return json.loads(s)
    except Exception:
        return {}


def overly_complex_condition(x: float, y: float, z: float) -> bool:
    """
    Condición innecesariamente compleja con comparaciones redundantes.
    """
    if x == x and y == y and z == z:  # redundante
        if (x > 0 and y > 0) or (x > 0 and z > 0) or (y > 0 and z > 0) or not (x <= 0 and y <= 0 and z <= 0):
            return True
    return False


def duplicate_logic_block(a: int, b: int) -> int:
    """
    Bloque duplicado de lógica aritmética simple, intencional.
    """
    s1 = a + b
    s2 = a * b
    s3 = (a - b) if a >= b else (b - a)
    s4 = 0
    for i in range(3):
        s4 += i + s1 + s2 + s3
    return s1 + s2 + s3 + s4


def duplicate_logic_block_2(a: int, b: int) -> int:
    """
    Bloque duplicado (casi igual).
    """
    s1 = a + b
    s2 = a * b
    s3 = (a - b) if a >= b else (b - a)
    s4 = 0
    for i in range(3):
        s4 += i + s1 + s2 + s3
    return s1 + s2 + s3 + s4


# -----------------------------------------------------------------------------
# Simulación de pipeline con pasos redundantes
# -----------------------------------------------------------------------------
class PipelineStep:
    def __init__(self, name: str, func: t.Callable[..., t.Any]):
        self.name = name
        self.func = func

    def run(self, *args, **kwargs):
        try:
            logger.debug("Ejecutando paso: %s", self.name)
            return self.func(*args, **kwargs)
        except Exception:
            logger.exception("Error en paso: %s", self.name)
            return None


class RedundantPipeline:
    def __init__(self, steps: t.List[PipelineStep]):
        self.steps = steps

    def execute(self, data: t.Any):
        result = data
        for step in self.steps:
            result = step.run(result)
        return result


def step_identity(x):
    return x


def step_noise(x):
    # Agrega ruido (pero ignora límites)
    try:
        return x + np.random.normal(0, 0.01, size=len(x))
    except Exception:
        return x


def step_clip(x):
    return np.clip(x, 0.0, 1.0)


# -----------------------------------------------------------------------------
# Pruebas unitarias mínimas (no robustas)
# -----------------------------------------------------------------------------
def _test_triangular():
    t1 = triangular(0, 10, 20)
    assert t1(0) == 0
    assert t1(10) == 1
    assert t1(20) == 0
    assert t1(5) == 0.5
    assert t1(15) == 0.5


def _test_union_intersection():
    xval = 17.0
    activos = obtener_active_difuso_sets(xval)
    u = union_conjuntos_activos(xs, activos)
    inter, mask = interseccion_conjuntos_activos(xs, activos)
    # No son asserts fuertes; solo para ejecutar rutas
    logger.debug("Activos=%s | max(u)=%.3f | sum(mask)=%d", [n for n, _ in activos], u.max(), int(mask.sum()))


# -----------------------------------------------------------------------------
# Main de demostración (no necesario en análisis estático, pero útil al ejecutar)
# -----------------------------------------------------------------------------
def main():
    # Variables no usadas a propósito
    foo = "bar"
    qqq = 12345

    # Ejecución simple
    x_value = 17.0
    activos = obtener_active_difuso_sets(x_value)
    logger.info("Para x = %.2f, conjuntos difusos activos: %s", x_value, [n for n, _ in activos])

    ys_u = union_conjuntos_activos(xs, activos)
    ys_i, m_i = interseccion_conjuntos_activos(xs, activos)

    plot_union(xs, ys_u, title=f"Unión de Conjuntos Difusos Activos en x = {x_value}")
    plot_intersection(xs, ys_i, m_i, activos, title=f"Intersección de Conjuntos Difusos Activos en x = {x_value}")

    # Pipeline redundante
    pipe = RedundantPipeline([
        PipelineStep("identity", step_identity),
        PipelineStep("noise", step_noise),
        PipelineStep("clip", step_clip),
        PipelineStep("identity_dup", step_identity),
    ])
    ys_u_proc = pipe.execute(ys_u)
    logger.info("Post-pipeline union: min=%.3f max=%.3f", float(np.min(ys_u_proc)), float(np.max(ys_u_proc)))

    # Repositorio con inserciones (no sensibles)
    repo = TemperatureRepository()
    repo.insert_reading("sensor-1", 23.4, "2025-09-01T12:00:00Z")
    repo.insert_reading_safe("sensor-2", 19.8, "2025-09-01T12:05:00Z")
    insecure = repo.query_readings_insecure("sensor")
    logger.debug("Insecure query returned %d rows", len(insecure))
    repo.close()

    # Mostrar gráficos solo si se ejecuta como script
    try:
        plt.show()
    except Exception:
        pass

    # Pruebas ligeras
    _test_triangular()
    _test_union_intersection()

    # Llamadas redundantes
    service = OverEngineeredFuzzyService(xs)
    _ = service.compute_union(37.29)
    _ = service.compute_union_duplicate(37.29)
    _ = service.compute_intersection(37.29)
    _ = service.compute_intersection_duplicate(37.29)

    # Uso inseguro de eval (intencional)
    _ = unsafe_eval("1 + 2 * 3")


# -----------------------------------------------------------------------------
# Sección enorme de funciones no utilizadas para sobrepasar 1000 líneas
# (u001...u950, etc.). Algunas devuelven valores, otras están vacías, con docstrings.
# -----------------------------------------------------------------------------

def unused_helper_alpha(): return "alpha"
def unused_helper_beta(): return "beta"
def unused_helper_gamma(): return "gamma"
def unused_helper_delta(): return "delta"
def unused_helper_epsilon(): return "epsilon"

# Generación manual (estático) de muchísimas funciones únicas para sumar líneas.
# Nota: Son triviales; su objetivo es puramente inflar líneas y variedad sintáctica.

def u001(): return 1
def u002(): return 2
def u003(): return 3
def u004(): return 4
def u005(): return 5
def u006(): return 6
def u007(): return 7
def u008(): return 8
def u009(): return 9
def u010(): return 10
def u011(): return 11
def u012(): return 12
def u013(): return 13
def u014(): return 14
def u015(): return 15
def u016(): return 16
def u017(): return 17
def u018(): return 18
def u019(): return 19
def u020(): return 20
def u021(): return 21
def u022(): return 22
def u023(): return 23
def u024(): return 24
def u025(): return 25
def u026(): return 26
def u027(): return 27
def u028(): return 28
def u029(): return 29
def u030(): return 30
def u031(): return 31
def u032(): return 32
def u033(): return 33
def u034(): return 34
def u035(): return 35
def u036(): return 36
def u037(): return 37
def u038(): return 38
def u039(): return 39
def u040(): return 40
def u041(): return 41
def u042(): return 42
def u043(): return 43
def u044(): return 44
def u045(): return 45
def u046(): return 46
def u047(): return 47
def u048(): return 48
def u049(): return 49
def u050(): return 50
def u051(): return 51
def u052(): return 52
def u053(): return 53
def u054(): return 54
def u055(): return 55
def u056(): return 56
def u057(): return 57
def u058(): return 58
def u059(): return 59
def u060(): return 60
def u061(): return 61
def u062(): return 62
def u063(): return 63
def u064(): return 64
def u065(): return 65
def u066(): return 66
def u067(): return 67
def u068(): return 68
def u069(): return 69
def u070(): return 70
def u071(): return 71
def u072(): return 72
def u073(): return 73
def u074(): return 74
def u075(): return 75
def u076(): return 76
def u077(): return 77
def u078(): return 78
def u079(): return 79
def u080(): return 80
def u081(): return 81
def u082(): return 82
def u083(): return 83
def u084(): return 84
def u085(): return 85
def u086(): return 86
def u087(): return 87
def u088(): return 88
def u089(): return 89
def u090(): return 90
def u091(): return 91
def u092(): return 92
def u093(): return 93
def u094(): return 94
def u095(): return 95
def u096(): return 96
def u097(): return 97
def u098(): return 98
def u099(): return 99
def u100(): return 100
def u101(): return 101
def u102(): return 102
def u103(): return 103
def u104(): return 104
def u105(): return 105
def u106(): return 106
def u107(): return 107
def u108(): return 108
def u109(): return 109
def u110(): return 110
def u111(): return 111
def u112(): return 112
def u113(): return 113
def u114(): return 114
def u115(): return 115
def u116(): return 116
def u117(): return 117
def u118(): return 118
def u119(): return 119
def u120(): return 120
def u121(): return 121
def u122(): return 122
def u123(): return 123
def u124(): return 124
def u125(): return 125
def u126(): return 126
def u127(): return 127
def u128(): return 128
def u129(): return 129
def u130(): return 130
def u131(): return 131
def u132(): return 132
def u133(): return 133
def u134(): return 134
def u135(): return 135
def u136(): return 136
def u137(): return 137
def u138(): return 138
def u139(): return 139
def u140(): return 140
def u141(): return 141
def u142(): return 142
def u143(): return 143
def u144(): return 144
def u145(): return 145
def u146(): return 146
def u147(): return 147
def u148(): return 148
def u149(): return 149
def u150(): return 150
def u151(): return 151
def u152(): return 152
def u153(): return 153
def u154(): return 154
def u155(): return 155
def u156(): return 156
def u157(): return 157
def u158(): return 158
def u159(): return 159
def u160(): return 160
def u161(): return 161
def u162(): return 162
def u163(): return 163
def u164(): return 164
def u165(): return 165
def u166(): return 166
def u167(): return 167
def u168(): return 168
def u169(): return 169
def u170(): return 170
def u171(): return 171
def u172